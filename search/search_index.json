{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-pydaq-documentation","title":"Welcome to PYDAQ documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>PYDAQ (Python Data Acquisition and Experimental Analysis) is a framework designed to support experimental data acquisition, real-time analysis, system identification, and control using Python. It provides an integrated environment for working with Arduino and National Instruments NIDAQ boards, supporting both graphical and command-line workflows.</p> <p>Initially focused on basic data acquisition and signal generation for experiments such as step-response tests, PYDAQ has evolved into a broader experimental platform. Its development milestones are:</p> <ul> <li>Version v0.0.5 introduced real-time system identification, enabling the estimation of linear and nonlinear black-box models directly from experimental data.</li> <li>Version v0.0.6 expanded PYDAQ with real-time digital filtering (FIR and IIR) and classical control techniques, including PID control with Ziegler\u2013Nichols tuning, supporting both simulation and live experiments.</li> </ul> <p>PYDAQ can be used through a Graphical User Interface (GUI) for rapid experimentation or via a command-line interface for scripting, automation, and advanced workflows. These features make the framework suitable for research, teaching laboratories, and rapid prototyping involving empirical data.</p>"},{"location":"#installation-and-requirements","title":"Installation and Requirements","text":"<p>The fastest way to install PYDAQ is using <code>pip</code>:</p> <pre><code>pip install pydaq\n</code></pre> <p>PYDAQ requires:</p> <ul> <li>Driver of the board used (Arduino or National Instruments NIDAQ)</li> <li><code>nidaqmx (&gt;=0.6.5)</code> for data acquisition from National Instruments boards</li> <li><code>matplotlib (&gt;=3.5.3)</code> for data visualization</li> <li><code>numpy (&gt;=1.22.3)</code> for numerical processing</li> <li><code>PySide6 (&gt;=6.7.1)</code>, <code>PySide6_Addons</code>, <code>PySide6_Essentials</code>, and <code>shiboken6</code> for the graphical user interface</li> <li><code>pyserial (&gt;=3.5)</code> for communication with Arduino boards</li> <li><code>sysidentpy (==0.3.4)</code> and <code>bitarray (&gt;=3.0.0)</code> for system identification and signal generation</li> <li><code>packaging (&gt;=24.1)</code></li> <li><code>scipy (&gt;=1.16.1)</code> for digital filters and PID control</li> </ul> <p>Note: In version v0.0.6, NI-DAQmx drivers must be installed even if only Arduino boards are used. This limitation will be addressed in future releases.</p>"},{"location":"#documentation-map","title":"Documentation Map","text":""},{"location":"#data-acquisition","title":"Data Acquisition","text":"<p>Examples showing how to acquire data using either the GUI or the command line with:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul>"},{"location":"#sending-data","title":"Sending Data","text":"<p>How to generate and send excitation or custom signals using:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul> <p>Both GUI-based and command-line approaches are covered.</p>"},{"location":"#step-response","title":"Step Response","text":"<p>Configuration and execution of step-response experiments with:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul>"},{"location":"#get-model-system-identification","title":"Get Model (System Identification)","text":"<p>Documentation on estimating mathematical models from experimental data using:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul> <p>This includes real-time identification workflows introduced in v0.0.5.</p>"},{"location":"#pid-control","title":"PID Control","text":"<p>Guidelines for performing real-time or simulated PID control, including Ziegler\u2013Nichols tuning, using:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul> <p>Controller configuration and closed-loop experiments are supported through the GUI.</p>"},{"location":"#digital-filters","title":"Digital Filters","text":"<p>Design and real-time application of FIR and IIR digital filters using:</p> <ul> <li>Arduino</li> <li>NIDAQ</li> </ul> <p>Filter parameters such as cutoff frequency and order can be configured via the graphical interface, with support for simulation and live data processing. These features were introduced in v0.0.6.</p>"},{"location":"#benchmarking","title":"Benchmarking","text":"<p>This section provides a benchmarking tool to estimate the maximum reliable sampling frequency supported by the user\u2019s system. It helps identify practical limits for real-time or high-speed data acquisition without data loss.</p> <p>Instructions on how to run and interpret the benchmark are available at: Benchmarking tool documentation</p>"},{"location":"#examples","title":"Examples","text":"<p>This section provides Jupyter Notebook examples demonstrating PYDAQ functionalities for both:</p> <ul> <li>NIDAQ</li> <li>Arduino</li> </ul>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"benchmarking/","title":"Benchmarking","text":""},{"location":"benchmarking/#benchmarking-minimum-supported-sampling-period-evaluation","title":"Benchmarking \u2013 Minimum Supported Sampling Period Evaluation","text":"<p>This benchmarking function was developed to test the computer's performance under high-frequency data acquisition conditions. Its primary purpose is to evaluate how the system behaves when subjected to extremely low sampling periods, simulating real-time processing demands.</p> <p>The function runs a controlled loop for a specified duration, attempting to execute iterations at fixed time intervals defined by the user. During execution, the actual time between each iteration is measured and logged. This allows for the analysis of processing consistency, timing deviations, and the system's ability to maintain the desired sampling rate.</p> <p>At the end of the test, the function automatically estimates and reports the minimum sampling period that the system can reliably support without significant timing violations or data loss. This result helps developers understand the performance limits of the target machine and configure their applications accordingly.</p> <p></p>"},{"location":"digital_filters_arduino/","title":"Digital Filters Arduino","text":""},{"location":"digital_filters_arduino/#filtering-using-graphical-user-interface-gui","title":"Filtering using Graphical User Interface (GUI)","text":"<p>Using the digital filters through the GUI is very simple, and with just two lines of code, you can open the GUI:</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> <p>After running the command, the GUI will appear. Navigate to the 'Get Data' screen, where you'll see a radio button to choose whether or not to apply the digital filters. When the 'Yes' option is selected, a new window will appear.</p> <p></p>"},{"location":"digital_filters_arduino/#parameters","title":"Parameters","text":"<ul> <li> <p>Filter: Select the type of filter to use \u2014 FIR or IIR.</p> </li> <li> <p>Plot frequency response: Choose whether to display the filter's frequency response after data acquisition.</p> </li> <li> <p>Filter design: Select the design method for the filter.</p> </li> <li> <p>Order: Specify the filter order by entering a numerical value.</p> </li> <li> <p>Type: Define the filter type \u2014 choose from Lowpass, Highpass, Bandpass, or Bandstop.</p> </li> <li> <p>Cutoff: Set the filter\u2019s cutoff frequency (or frequencies, depending on the filter type).</p> </li> </ul>"},{"location":"digital_filters_arduino/#real-time-filter","title":"Real-Time Filter","text":"<p>After configuring the digital filter parameters, they will be applied to the real-time data acquisition, as shown in the image below:</p> <p></p>"},{"location":"digital_filters_nidaq/","title":"NIDAQ Digital Filters","text":"<p>NOTE: Before working with PYDAQ, the device driver should be installed and working correctly as a DAQ (Data Acquisition) device.</p>"},{"location":"digital_filters_nidaq/#filtering-using-graphical-user-interface-gui","title":"Filtering using Graphical User Interface (GUI)","text":"<p>Using the digital filters through the GUI is very simple, and with just two lines of code, you can open the GUI:</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> <p>After running the command, the GUI will appear. Navigate to the 'Get Data' screen, where you'll see a radio button to choose whether or not to apply the digital filters. When the 'Yes' option is selected, a new window will appear.</p> <p></p>"},{"location":"digital_filters_nidaq/#parameters","title":"Parameters","text":"<ul> <li> <p>Filter: Select the type of filter to use \u2014 FIR or IIR.</p> </li> <li> <p>Plot frequency response: Choose whether to display the filter's frequency response after data acquisition.</p> </li> <li> <p>Filter design: Select the design method for the filter.</p> </li> <li> <p>Order: Specify the filter order by entering a numerical value.</p> </li> <li> <p>Type: Define the filter type \u2014 choose from Lowpass, Highpass, Bandpass, or Bandstop.</p> </li> <li> <p>Cutoff: Set the filter\u2019s cutoff frequency (or frequencies, depending on the filter type).</p> </li> </ul>"},{"location":"digital_filters_nidaq/#real-time-filter","title":"Real-Time Filter","text":"<p>After configuring the digital filter parameters, they will be applied to the real-time data acquisition, as shown in the image below:</p> <p></p>"},{"location":"get_data_arduino/","title":"Data Acquisition with Arduino","text":"<p>NOTE 1: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p> <p>NOTE 2 To acquire/send data with arduino, the code provided here (located at arduino_code) should be firstly uploaded in Arduino. Default input port is A0 and this port can be changed in the above mentioned code.</p> <p>NOTE 3 PYDAQ is programmed to use 10 bits as a ADC resolution, and 0V and 5V as the input range. To change this, the user can alter the following variables:</p> <pre><code>self.arduino_ai_bits = 10\nself.ard_ai_max = 5\nself.ard_ai_min = 0\n</code></pre>"},{"location":"get_data_arduino/#data-acquisition-using-graphical-user-interface-gui","title":"Data Acquisition using Graphical User Interface (GUI)","text":"<p>Using GUI to acquire data is really straighforward and require only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the following screen will show up, where the user should select the Arduino option and go to the Get Data tab, to be able to define parameters and start to acquire data.</p> <p></p> <p>The user is now able to select desired device, sample period and session duration. Also, the user will define if the data will or not be plotted and saved, as well as the path to save data.</p>"},{"location":"get_data_arduino/#data-acquisition-using-command-line","title":"Data Acquisition using command line","text":"<p>It will be presented how to use GetData (and get_data_arduino) to acquire signal using an Arduino board.</p> <p>Firstly, import library and define parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.get_data import GetData\n\n# Defining parameters\nsample_period_in_seconds = 1\nsession_duration_in_seconds = 10.0\ncom_port_arduino = 'COM3'\nsave_data = True\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with defined parametes and get the data</p> <pre><code># Class GetData\ng = GetData(com=com_port_arduino,\n            ts=sample_period_in_seconds,\n            session_duration=session_duration_in_seconds,\n            save=save_data,\n            plot_mode=will_plot)\n\n# Method get_data_arduino\ng.get_data_arduino()\n</code></pre> <p>NOTE: data will be saved on desktop, by default. To change the path the user can define \"g.path = Desired path\"</p>"},{"location":"get_data_arduino/#presenting-acquired-data","title":"Presenting acquired data","text":"<p>To show acquired data, type:</p> <pre><code>print(f'First 10 values of time: \\n {g.time_var[0:10]}')\nprint(f'\\nFirst 10 values of data: \\n {g.data[0:10]}')\n</code></pre> <p>If you choose to plot you can see acquired data on screen, i.e:</p> <p></p> <p>Data will also be saved as depicted below:</p> <p></p> <p>You can see more detailed bellow: </p> <p></p>"},{"location":"get_data_nidaq/","title":"Data Acquisition with NIDAQ Boards","text":"<p>NOTE: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p>"},{"location":"get_data_nidaq/#data-acquisition-using-graphical-user-interface-gui","title":"Data Acquisition using Graphical User Interface (GUI)","text":"<p>Using GUI to acquire data is really straightforward and requires only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the graphical user interface screen will show up, where the user should select the NIDAQ option and go to the Get Data tab, to define parameters and start acquiring data.</p> <p></p> <p>The user is now able to select the desired device, channel, terminal configuration (Differential, RSE and NRSE), sample period and session duration. Also, the user will define if the data will be plotted and saved or not, as well as the path to save data.</p>"},{"location":"get_data_nidaq/#data-acquisition-using-command-line","title":"Data Acquisition using command line","text":"<p>It will be presented how to use GetData (and get_data_nidaq) to acquire signal using a National Instruments board.</p> <p>Firstly, import the library and define the parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.get_data import GetData\n\n# Defining parameters\ndevice_name = \"Dev1\"\nchannel_used = \"ai0\"\nterminal_configuration = 'Diff'\nsample_period_in_seconds = 1\nsession_duration_in_seconds = 10.0\nsave_data = True\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with the defined parameters and get the data</p> <pre><code># Class GetData\ng = GetData(device=device_name,\n            channel=channel_used,\n            terminal=terminal_configuration,\n            ts=sample_period_in_seconds,\n            session_duration=session_duration_in_seconds,\n            save=save_data,\n            plot_mode=will_plot)\n\n# Method get_data_nidaq\ng.get_data_nidaq()\n</code></pre> <p>NOTE: data will be saved on the desktop, by default. To change the path, the user can define \"g.path = Desired path\"</p>"},{"location":"get_data_nidaq/#presenting-the-acquired-data","title":"Presenting the acquired data","text":"<p>To show acquired data, type:</p> <pre><code>print(f'First 10 values of time: \\n {g.time_var[0:10]}')\nprint(f'\\nFirst 10 values of data: \\n {g.data[0:10]}')\n</code></pre> <p>If you choose to plot, you can see acquired data on screen, i.e:</p> <p></p> <p>Data will also be saved as depicted as shown below:</p> <p></p> <p>You can see more detailed bellow:</p> <p></p>"},{"location":"get_model_arduino/","title":"Model Acquisition with Arduino","text":"<p>NOTE 1: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p> <p>NOTE 2: To get models with Arduino, the code provided here  should be firstly uploaded in your Arduino board. Default input port is A0, and default output port is 13. Those ports can be changed  in the above-mentioned code. This code only works with digital output, since this is a limitation of Arduino Boards.</p> <p>NOTE 3: PYDAQ is programmed to use 10 bits as an ADC resolution, and 0V and 5V as the input range. To change this, the user can alter the following variables:</p> <pre><code>self.arduino_ai_bits = 10\nself.ard_ai_max = 5\nself.ard_ai_min = 0\n</code></pre>"},{"location":"get_model_arduino/#adquiring-the-model-using-graphical-user-interface-gui","title":"Adquiring the model using Graphical User Interface (GUI)","text":"<p>Using GUI to adquire the model is really straighforward and  require only two LOC (lines of code):</p> <p><pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> After this command, the following screen will show up. In \"Get Model\"  screen the user is able to define parameters and start the experiment to adquire the model.</p> <p></p>"},{"location":"get_model_arduino/#parameters","title":"Parameters","text":"<ul> <li> <p>Choose your Arduino: This option allows you to choose the Arduino you are going to use.</p> </li> <li> <p>Sample Period: The user can change the sample period, i.e., time (in seconds) between samples.</p> </li> <li> <p>Start saving data: Choose when the data will start being recorded to obtain the model.</p> </li> <li> <p>Session duration: The user can choose the session duration.</p> </li> <li> <p>Plot and Save data: The user can choose whether to plot and save the data.</p> </li> <li> <p>Path: Choose where data will be saved.</p> </li> </ul>"},{"location":"get_model_arduino/#input-signal","title":"Input Signal","text":""},{"location":"get_model_arduino/#prbs","title":"PRBS","text":"<p>A pseudorandom binary sequence (PRBS) is a deterministic signal that alternates between two values and exhibits characteristics similar to white noise. The PRBS signal is inherently periodic, with a maximum period length of 2\u207f\u20131, where n represents the order of the PRBS. For more information: Nonlinear System Identification: Theory and Practice with Sysidentpy.</p> <p>In the Config signal button, the user can customize the signal parameters.</p>"},{"location":"get_model_arduino/#advanced-settings","title":"Advanced Settings","text":"<p>The library used for obtaining mathematical models is SysidentPy. It is a Python module for System Identification using NARMAX models, built on top of numpy and distributed under the 3-Clause BSD license. You can configure its parameters and customize the way the mathematical model is obtained. Read more about this in the SysidentPy documentation.</p> <p>By pressing the Get Model button, the program will start and the model will be obtained.</p>"},{"location":"get_model_arduino/#run-get-model-from-the-command-line","title":"Run Get model from the command line","text":"<p><pre><code># Importing PYDAQ\nfrom pydaq.get_model import GetModel\n\n# Defining parameters\ncom_port_arduino = 'COM3'\nsession_duration_in_s = 100\nsample_period_in_s = 0.5\nsave_data = True\nplot_data = \"no\"\n\n# system identification parameters\ndegree = 2\nstart_save_time_in_s = 0\nout_lag = 2\ninp_lag = 2\nnum_info_val = 6\nestimator = 'least_squares'\next_lsq = True\nperc_value_to_train_the_model = 15\n\n# PRBS input parameters\nprbs_bits = 6\nprbs_seed = 100\nvar_tb = 1\n\n# Class GetModel\ng = GetModel(\n    com= com_port_arduino,\n    session_duration= session_duration_in_s,\n    ts= sample_period_in_s,\n    save= save_data,\n    plot_mode= plot_data,\n    degree= 2,\n    start_save_time= start_save_time_in_s,\n    out_lag= out_lag,\n    inp_lag= inp_lag,\n    num_info_values= num_info_val,\n    estimator= estimator,\n    ext_lsq= ext_lsq,\n    perc_value= perc_value_to_train_the_model,\n    prbs_bits= prbs_bits,\n    prbs_seed= prbs_seed,\n    var_tb= var_tb\n    )\n\n# Method get_model_arduino\ng.get_model_arduino()\n</code></pre> NOTE: data will be saved on desktop, by default. To change the path the user can define \"g.path = Desired path\".</p> <p>If the user chooses to plot, this screen will appear:</p> <p></p> <p>At the end of the user-defined time, screens with the results will be shown as depicted below.</p>"},{"location":"get_model_arduino/#example-gif","title":"Example GIF","text":""},{"location":"get_model_nidaq/","title":"Model Acquisition with NIDAQ Boards","text":"<p>NOTE: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p>"},{"location":"get_model_nidaq/#adquiring-the-model-using-graphical-user-interface-gui","title":"Adquiring the model using Graphical User Interface (GUI)","text":"<p>Using GUI to adquire the model is really straighforward and  require only two LOC (lines of code):</p> <p><pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> After this command, the following screen will show up. In \"Get Model\"  screen the user is able to define parameters and start the experiment to adquire the model.</p> <p></p>"},{"location":"get_model_nidaq/#parameters","title":"Parameters","text":"<ul> <li> <p>Choose Device: The user is able to select desired device.</p> </li> <li> <p>Choose Channel: The user is able to select desired channel.</p> </li> <li> <p>Terminal Configuration: The user can change terminal configuration (Differential, RSE and NRSE).</p> </li> <li> <p>Sample Period: The user can change the sample period, i.e., time (in seconds) between samples.</p> </li> <li> <p>Start Saving Data: Choose when data will start being recorded to obtain the model.</p> </li> <li> <p>Session Duration: The user can choose the session duration, which will change the number of iterations.</p> </li> <li> <p>Plot and Save data: The user can choose whether to plot and save the data.</p> </li> <li> <p>Path: Choose where the data will be saved.</p> </li> </ul>"},{"location":"get_model_nidaq/#input-signal","title":"Input Signal","text":""},{"location":"get_model_nidaq/#prbs","title":"PRBS","text":"<p>A pseudorandom binary sequence (PRBS) is a deterministic signal that alternates between two values and exhibits characteristics similar to white noise. The PRBS signal is inherently periodic, with a maximum period length of 2\u207f\u20131, where n represents the order of the PRBS. For more information: Nonlinear System Identification: Theory and Practice with Sysidentpy</p> <p>In the Config signal button, the user can customize the signal parameters.</p>"},{"location":"get_model_nidaq/#advanced-settings","title":"Advanced Settings","text":"<p>The library used for obtaining mathematical models is SysidentPy. It is a Python module for System Identification using NARMAX models, built on top of numpy and distributed under the 3-Clause BSD license. You can configure its parameters and customize the way the mathematical model is obtained. Read more about this in the SysidentPy documentation.</p> <p>By pressing the Get Model button, the program will start and the model will be obtained.</p>"},{"location":"get_model_nidaq/#run-get-model-from-the-command-line","title":"Run Get model from the command line","text":"<p><pre><code># Importing PYDAQ\nfrom pydaq.get_model import GetModel\n\n# Defining parameters\ndevice_name = \"Dev1\"\nao_channel = \"ao0\"\nai_channel = \"ai0\"\nchannel = \"ai0\"\nterminal = \"Diff\"\nao_min = 0\nao_max = 5\nsession_duration_in_s = 10\nsample_period_in_s = 0.5\nsave_data = True\nplot_data = \"realtime\"\n\n# system identification parameters\ndegree = 2\nstart_save_time_in_s = 0\nout_lag = 2\ninp_lag = 2\nnum_info_val = 6\nestimator = \"least_squares\"\next_lsq = True\nperc_value_to_train_the_model = 15\n\n# PRBS input parameters\nprbs_bits = 6\nprbs_seed = 100\nvar_tb = 1\n\n# Class GetModel\ng = GetModel(\n    device=device_name,\n    ai_channel=ai_channel,\n    ao_channel=ao_channel,\n    ao_min=ao_min,\n    ao_max=ao_max,\n    channel=channel,\n    terminal=terminal,\n    session_duration= session_duration_in_s,\n    ts= sample_period_in_s,\n    save= save_data,\n    plot_mode= plot_data,\n    degree=degree,\n    start_save_time=start_save_time_in_s,\n    out_lag=out_lag,\n    inp_lag=inp_lag,\n    num_info_values=num_info_val,\n    estimator=estimator,\n    ext_lsq=ext_lsq,\n    perc_value=perc_value_to_train_the_model,\n    prbs_bits=prbs_bits,\n    prbs_seed=prbs_seed,\n    var_tb=var_tb,\n)\n\n# Method get_model_nidaq\ng.get_model_nidaq()\n</code></pre> NOTE: data will be saved on desktop, by default. To change the path the user can define \"g.path = Desired path\".</p> <p>If the user chooses to plot, this screen will appear:</p> <p></p> <p>At the end of the user-defined time, screens with the results will be shown as depicted below.</p> <p></p>"},{"location":"jupyter_notebooks/","title":"Jupyter Notebooks","text":"<p>A full set of jupyter notebooks with several examples  of how to use NIDAQ and Arduino for data acquisition,  send data and other experiments can be found on Github repository.</p>"},{"location":"pid_control_arduino/","title":"PID Control with Arduino","text":"<p>NOTE 1: Before working with PYDAQ, the device driver should be installed and working correctly as a DAQ (Data Acquisition) device.</p> <p>NOTE 2: To perform control with Arduino, the code provided here must be uploaded to your Arduino board. The default input port is A0, and the default output port is 13. These ports can be changed in the aforementioned code. This code only works with digital output due to limitations of Arduino boards.</p> <p>NOTE 3: PYDAQ is programmed to use 10 bits as ADC resolution and 0V to 5V as the input range. To change this, the user can alter the following variables:</p> <pre><code>self.arduino_ai_bits = 10\nself.ard_ai_max = 5\nself.ard_ai_min = 0\n</code></pre>"},{"location":"pid_control_arduino/#controlling-using-graphical-user-interface-gui","title":"Controlling using Graphical User Interface (GUI)","text":"<p>Using the GUI to perform PID control is very straightforward and requires only two lines of code:</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> <p>After running the command, the GUI will appear. Navigate to the \"PID Control\" screen, where you can define the parameters and start the control session.</p> <p></p>"},{"location":"pid_control_arduino/#parameters","title":"Parameters","text":"<ul> <li> <p>Simulate: If this option is selected, you can enter a mathematical equation to simulate a system and apply PID control to it.</p> </li> <li> <p>Device: Select the Arduino board connected to your system.</p> </li> <li> <p>Setpoint: Define the desired reference value for the system.</p> </li> <li> <p>Unit (optional): Define the unit of measurement for the setpoint (e.g., \u00b0C, rpm, volts).</p> </li> <li> <p>Equation (optional): Define a mathematical transformation for the measured input, if needed.</p> </li> <li> <p>Sampling Period: Time interval (in seconds) between each data sample.</p> </li> <li> <p>Controller Type: Choose among P, PI, PD, or PID controllers and configure their respective tuning parameters.</p> </li> <li> <p>Save Data: Choose whether to save the recorded data during the session.</p> </li> <li> <p>Path: Define where the data files will be saved.</p> </li> </ul>"},{"location":"pid_control_arduino/#simulated-system","title":"Simulated System","text":"<p>If you enable the Simulate option, the software will not require a physical device. Instead, you can input the transfer function or system equation, and PYDAQ will simulate its response using the defined controller parameters.</p> <p>This is useful for testing your control strategy before applying it to a real system.</p>"},{"location":"pid_control_arduino/#real-time-control","title":"Real-Time Control","text":"<p>After adjusting the parameters and starting the control, a new window will open to display the real-time control process. Within this window, you can also modify the PID parameters (kp, ki, kd) and the setpoint during execution.</p> <p>A disturbance input can also be simulated during real-time control. It acts as a negative signal added after the control signal, as illustrated in the figure below.</p>"},{"location":"pid_control_arduino/#example-gif","title":"Example GIF","text":""},{"location":"pid_control_arduino/#control-pid-with-arduino-gui-via-code","title":"Control PID with Arduino (GUI via code)","text":"<p>It is possible to access the PID Control GUI directly with a few lines of code.</p>"},{"location":"pid_control_arduino/#example","title":"Example","text":"<p>The following code demonstrates how to automatically find an Arduino board and launch the control interface with predefined PID parameters.</p> <pre><code>import sys, os, serial.tools.list_ports\nfrom PySide6.QtWidgets import QApplication\nfrom pydaq.pydaq.guis.pid_control_window_dialog import PID_Control_Window_Dialog\n\napp = QApplication(sys.argv)\nplot_window = PID_Control_Window_Dialog()\n\n# Select Arduino port automatically\ncom_port = serial.tools.list_ports.comports()[0].name\nplot_window.check_board(board=\"arduino\", device=com_port, ao=None, ai=None, terminal=None, simulate=False)\n\n# Define PID parameters\nkp, ki, kd, setpoint, period = 1.0, 0.2, 0.05, 2.0, 0.1\nindex, path, save = 3, None, True  \n\n# index = 0 -&gt; P, 1 -&gt; PI, 2 -&gt; PD, 3 -&gt; PID.\n\n# when path = None, by defaut saves to C:\\Users\\Desktop\n\nplot_window.set_parameters(kp, ki, kd, index, \" \", \" \", setpoint, \"Voltage (V)\", \"\", \"\", period, path, save)\n\n# Open GUI\nplot_window.exec()\n</code></pre> <ul> <li> <p>check_board: selects Arduino as the control device.</p> </li> <li> <p>set_parameters: sets gains, setpoint, sampling period, and save path.</p> </li> <li> <p>exec(): opens the control interface.</p> </li> </ul>"},{"location":"pid_control_nidaq/","title":"PID Control with NIDAQ","text":"<p>NOTE: Before working with PYDAQ, the device driver should be installed and working correctly as a DAQ (Data Acquisition) device.</p>"},{"location":"pid_control_nidaq/#controlling-using-graphical-user-interface-gui","title":"Controlling using Graphical User Interface (GUI)","text":"<p>Using the GUI to perform PID control is very straightforward and requires only two lines of code:</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\nPydaqGui()\n</code></pre> <p>After running the command, the GUI will appear. Navigate to the \"PID Control\" screen, where you can define the parameters and start the control session.</p> <p></p>"},{"location":"pid_control_nidaq/#parameters","title":"Parameters","text":"<ul> <li> <p>Simulate: If this option is selected, you can enter a mathematical equation to simulate a system and apply PID control to it.</p> </li> <li> <p>Device: Select the NIDAQ board connected to your system.</p> </li> <li> <p>AI channel and AO channel: Specify the analog input (AI) and output (AO) channels used by your device.</p> </li> <li> <p>Terminal Configuration: The user can change terminal configuration (Differential, RSE and NRSE).</p> </li> <li> <p>Setpoint: Define the desired reference value for the system.</p> </li> <li> <p>Unit (optional): Define the unit of measurement for the setpoint (e.g., \u00b0C, rpm, volts).</p> </li> <li> <p>Equation (optional): Define a mathematical transformation for the measured input, if needed.</p> </li> <li> <p>Sampling period: Time interval (in seconds) between each data sample.</p> </li> <li> <p>Controller type: Choose among P, PI, PD, or PID controllers and configure their respective tuning parameters.</p> </li> <li> <p>Save data: Choose whether to save the recorded data during the session.</p> </li> <li> <p>Path: Define where the data files will be saved.</p> </li> </ul>"},{"location":"pid_control_nidaq/#simulated-system","title":"Simulated System","text":"<p>If you enable the Simulate option, the software will not require a physical device. Instead, you can input the transfer function or system equation, and PYDAQ will simulate its response using the defined controller parameters.</p> <p>This is useful for testing your control strategy before applying it to a real system.</p>"},{"location":"pid_control_nidaq/#real-time-control","title":"Real-Time Control","text":"<p>After adjusting the parameters and starting the control, a new window will open to display the real-time control process. Within this window, you can also modify the PID parameters (kp, ki, kd) and the setpoint during execution.</p> <p>A disturbance input can also be simulated during real-time control. It acts as a negative signal added after the control signal, as illustrated in the figure below.</p>"},{"location":"pid_control_nidaq/#example-gif","title":"Example GIF","text":""},{"location":"pid_control_nidaq/#control-pid-with-nidaq-gui-via-code","title":"Control PID with NIDAQ (GUI via code)","text":"<p>It is possible to access the PID Control GUI for NIDAQ devices directly with a few lines of code.</p>"},{"location":"pid_control_nidaq/#example","title":"Example","text":"<p>The following code demonstrates how to set up and launch the control interface for an NI-DAQ device, specifying the device name and the analog input and output channels.</p> <pre><code>import sys, os, serial.tools.list_ports\nfrom PySide6.QtWidgets import QApplication\nfrom pydaq.pydaq.guis.pid_control_window_dialog import PID_Control_Window_Dialog\n\napp = QApplication(sys.argv)\nplot_window = PID_Control_Window_Dialog()\n\n# Selection NIDAQ board\nplot_window.check_board(board=\"nidaq\", device=\"Dev1\", ao=\"ao0\", ai=\"ai0\", terminal=\"RSE\", simulate=False)\n\n# Define PID parameters\nkp, ki, kd, setpoint, period = 1.0, 0.2, 0.05, 2.0, 0.1\nindex, path, save = 3, None, True  \n# index = 0 -&gt; P, 1 -&gt; PI, 2 -&gt; PD, 3 -&gt; PID.\n\n# when path = None, by defaut saves to C:\\Users\\Desktop\n\nplot_window.set_parameters(kp, ki, kd, index, \" \", \" \", setpoint, \"Voltage (V)\", \"\", \"\", period, path, save)\n\n# Open GUI\nplot_window.exec()\n</code></pre> <ul> <li> <p>check_board: Selects and configures the NI-DAQ device. You must specify the device name (device), the analog output channel (ao), the analog input channel (ai), and the terminal configuration (terminal).</p> </li> <li> <p>set_parameters: Sets the controller gains, setpoint, sampling period, and the path to save the data.</p> </li> <li> <p>exec(): Opens the real-time control interface.</p> </li> </ul>"},{"location":"send_data_arduino/","title":"Sending Data with Arduino Boards","text":"<p>NOTE 1: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p> <p>NOTE 2: To acquire/send data with arduino, the code provided here (located at arduino_code) should be uploaded in Arduino first. Default output port is 13 and this port can be changed in the above mentioned code. This code only works with digital output, since this is a limitation of Arduino Boards.</p> <p>NOTE 3: Since are used digital output ports, the output will be 0V if data &lt; 2.5 and 5V otherwise.</p>"},{"location":"send_data_arduino/#sending-data-using-graphical-user-interface-gui","title":"Sending Data using Graphical User Interface (GUI)","text":"<p>Using GUI to send data is really straighforward and require only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the graphical user interface screen will show up, where the user should select the Arduino option and go to the Send Data tab, to be able to define parameters and start to send the data.</p> <p></p> <p>The user is now able to select desired Arduino and sample period. Also, the user will define if the data will or not be plotted. The data that will be sent should be in the range (0-5V).</p> <p>Data should be formated as one data per line and saved as a .dat file. After configuration is done, the user only need to click on SEND DATA button to start the process.</p>"},{"location":"send_data_arduino/#sending-data-using-command-line","title":"Sending data using command line","text":"<p>It will be presented how to use SendData (and send_data_arduino) to send a signal using an Arduino board.</p> <p>Firstly, import library and define parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.send_data import SendData\n\n# Defining parameters\nsample_period_in_seconds = 1\ndata = [0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 5, 5]  # It can be either a list or a numpy array\ncom_port_arduino = 'COM3'\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with defined parametes and send the data</p> <pre><code># Class SendData\ns = SendData(data=data,\n             com=com_port_arduino,\n             ts=sample_period_in_seconds,\n             plot_mode=will_plot)\n\n# Method send_data_arduino()\ns.send_data_arduino()\n</code></pre> <p>If you choose to plot you can see the data sent on screen, i.e:</p> <p></p>"},{"location":"send_data_nidaq/","title":"Sending Data with NIDAQ Boards","text":"<p>NOTE: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p>"},{"location":"send_data_nidaq/#sending-data-using-graphical-user-interface-gui","title":"Sending Data using Graphical User Interface (GUI)","text":"<p>Using GUI to send data is really straighforward and require only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the graphical user interface screen will show up, where the user should select the NIDAQ option and go to the Send Data tab, to be able to define parameters and start to send data.</p> <p></p> <p>The user is now able to select desired device, analog output channel and sample period. Also, the user will define if the data will or not be plotted. The data that will be sent should be in the output range defined, formated as one data per line and saved as a .dat file. After configuration is done, the user only need to click on SEND DATA button to start the process.</p>"},{"location":"send_data_nidaq/#sending-data-using-command-line","title":"Sending data using command line","text":"<p>It will be presented how to use SendData (and send_data_nidaq) to send a signal using a National Instruments board.</p> <p>Firstly, import library and define parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.send_data import SendData\n\n# Defining parameters\ndevice_name = \"Dev1\"\nchannel_used = \"ao0\"\nsample_period_in_seconds = 1\ndata = [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]  # It can be either a list or a numpy array\nao_min = 0  # Minimum allowed analog output value\nao_max = 5  # Maximum allowed analog output value\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with defined parametes and send the data</p> <pre><code># Class SendData\ns = SendData(data=data,\n             device=device_name,\n             channel=channel_used,\n             ts=sample_period_in_seconds,\n             ao_min=ao_min,\n             ao_max=ao_max,\n             plot_mode=will_plot)\n\n# Method send_data_nidaq\ns.send_data_nidaq()\n</code></pre> <p>If you choose to plot you can see the data sent on screen, i.e:</p> <p></p>"},{"location":"step_response_arduino/","title":"Step response with Arduino boards","text":"<p>NOTE 1: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p> <p>NOTE 2: To acquire/send data with arduino, the code provided here (located at arduino_code) should be firstly uploaded in Arduino. Default output port is 13 and analog input is A0 and these ports can be changed in the above-mentioned code. This code only works with digital output, since this is a limitation of Arduino Boards.</p> <p>NOTE 3: Since are used digital output ports, the output will be 0V for step minimum and 5V for step maximum.</p>"},{"location":"step_response_arduino/#step-response-using-graphical-user-interface-gui","title":"Step Response using Graphical User Interface (GUI)","text":"<p>Using GUI for step response is really straighforward and require only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the graphical user interface screen will show up, where the user should select the Arduino option and go to the Step Response tab, to be able to define parameters and start to acquire data.</p> <p></p> <p>The user is now able to select desired Arduino and sample period, as well as the session duration and the time when the step will be on. Also, the user will define if the data will or not be plotted and saved.</p>"},{"location":"step_response_arduino/#step-response-using-command-line","title":"Step Response using command line","text":"<p>It will be presented how to use StepResponse (and step_response_arduino) to perform a step response experiment using an Arduino board.</p> <p>Firstly, import library and define parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.step_response import StepResponse\n\n# Defining parameters\nsample_period_in_seconds = 1\nsession_duration_in_seconds = 10.0\nstep_time_in_seconds = 3.0\ncom_port_arduino = 'COM3'\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with defined parametes and send the data</p> <pre><code># Class StepResponse\ns = StepResponse(com=com_port_arduino,\n                 ts=sample_period_in_seconds,\n                 session_duration=session_duration_in_seconds,\n                 step_time=step_time_in_seconds,\n                 plot_mode=will_plot\n                 )\n\n# Method step_response_arduino\ns.step_response_arduino()\n</code></pre> <p>If you choose to plot you can see the data sent on screen, i.e:</p> <p></p> <p>You can see more detailed bellow:</p> <p></p>"},{"location":"step_response_nidaq/","title":"Step response with NIDAQ boards","text":"<p>NOTE 1: before working with PYDAQ, device driver should be installed and working correctly as a DAQ (Data Acquisition) device</p>"},{"location":"step_response_nidaq/#step-response-using-graphical-user-interface-gui","title":"Step Response using Graphical User Interface (GUI)","text":"<p>Using GUI for step response is really straighforward and require only two LOC (lines of code):</p> <pre><code>from pydaq.pydaq_global import PydaqGui\n\n# Launch the interface\nPydaqGui()\n</code></pre> <p>After this command, the graphical user interface screen will show up, where the user should select the NIDAQ option and go to the Step Response tab, to be able to define parameters and start to acquire data.</p> <p></p> <p>The user is now able to select desired NIDAQ device, analog input and analog output channel, as well as analog input terminal configuration. Step range and sample period can be adjusted along with session duration. Step will be applied in the defined time. Also, the user will define if the data will or not be plotted and saved.</p>"},{"location":"step_response_nidaq/#step-response-using-command-line","title":"Step Response using command line","text":"<p>It will be presented how to use StepResponse (and step_response_nidaq) to perform a step response experiment using an NIDAQ board.</p> <p>Firstly, import library and define parameters:</p> <pre><code># Importing PYDAQ\nfrom pydaq.step_response import StepResponse\n\n# Defining parameters\ndevice_name = \"Dev1\"\nao_channel_used = \"ao0\"\nai_channel_used = \"ai0\"\nsample_period_in_seconds = 1\nsession_duration_in_seconds = 10.0\nstep_time_in_seconds = 3.0\nstep_min_in_volts = 0\nstep_max_in_volts = 5\nterminal_configuration = 'Diff'\nwill_plot = \"no\" # Can be realtime, end or no\n</code></pre> <p>Then, instantiate a class with defined parametes and send the data</p> <pre><code># Class StepResponse\ns = StepResponse(device=device_name,\n                 ao_channel=ao_channel_used,\n                 ai_channel=ai_channel_used,\n                 ts=sample_period_in_seconds,\n                 session_duration=session_duration_in_seconds,\n                 step_time=step_time_in_seconds,\n                 step_min=step_min_in_volts,\n                 step_max=step_max_in_volts,\n                 terminal=terminal_configuration,\n                 plot_mode=will_plot)\n\n# Method step_response_nidaq\ns.step_response_nidaq()\n</code></pre> <p>If you choose to plot you can see the data sent on screen, i.e:</p> <p></p> <p>You can see more detailed bellow:</p> <p></p>"}]}